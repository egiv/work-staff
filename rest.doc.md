
## Зачем

Надеюсь, читающий уже понимает, зачем ему вообще нужен именно REST api, а не какой-нибудь монстр типа SOAP. Вопрос в том, зачем соблюдать какие-то стандарты и практики, если браузеры вроде бы позволяют делать что хочешь.

*   Стандарт HTTP это стандарт. Его несоблюдение вредно для кармы и ведёт к постоянным проблемам с безопасностью, кэшированием и прочими "закидонами" браузеров, которые совсем не закидоны, а просто следование стандарту.
*   Велосипеды со всякими `{error: "message","result":...}` невозможно нормально тестировать и отлаживать
*   Поддержка большим количеством готовых клиентских библиотек на все случаи жизни. Те, кто будет вашим api пользоваться, скажут большое человеческое спасибо.
*   Поддержка автоматизированного интеграционного тестирования. Когда сервер на любые запросы отдаёт `200 ОК` — ну, это такое себе развлечение.


## Структура запросов и ответов

Любой http-запрос начинается со строки

`METHOD URI`

где METHOD — это метод доступа (GET, PUT и т.д.), а URI — адрес запрашиваемого ресурса.

В начале запроса идут заголовки — просто текстовые строки вида `key: value`  
Затем передаётся пустая строка, означающая конец секции заголовков, и затем — тело запроса, если оно есть.

В ответе сначала передаётся строка с версией http, кодом и строковым статусом ответа (например `HTTP/1.1 200 OK`), далее текстовые заголовки ответа, потом пустая строка, потом тело ответа.

Тут вроде всё просто.

## Кодирование запросов и ответов

Кодировка для всех и запросов, и ответов — UTF-8 и только UTF-8, т.к. некоторые, кхм, "браузеры" имеют привычку игнорировать содержимое заголовка charset.

Использование кодов символов и html-сущностей не допускается, т.е. режим JSON_UNESCAPED_UNICODE **обязателен**. Не все клиенты знают всю таблицу html сущностей (типа каких-нибудь &ugrave; ), да и при чём тут html. Не все клиенты готовы/хотят заниматься перекодированием \uXXXX; и &#XX;. Плюс возможны "весёлые" ситуации с избыточным экранированием или пропаданием слэшей и амперсандов.

Все данные, кроме URI и двоичных файлов, передаются в формате [JSON](http://json.org/). Обратите внимание, что далеко не всякий валидный javascript код является валидным JSON.  
В частности, для строк используются только двойные кавычки. Одинарные кавычки в json-данных, хотя и допустимы в "обычном" javascript, могут вызвать непредсказуемые плохо отлавливаемые баги.

В запросах **обязательно** указывается заголовок

    Accept: application/json, */*; q=0.01

Вызовы к API отличаются от прочих вызовов (например, обычной загрузки html страницы по данному URI) именно по наличию application/json в Accept.

Сама строка Accept формируется браузером/клиентом и может немного отличаться от браузера к браузеру, например, наличием и других форматов типа `text/javascript`, поэтому нужно проверять не равенство, а именно вхождение "application/json".

В ответах 2хх с непустым телом **обязательно** наличие заголовка ответа

    Content-Type: application/json; charset=UTF-8

При наличии тела запроса также обязателен заголовок запроса

    Content-Type: application/json; charset=UTF-8

либо, при загрузке файлов,

    Content-Type: multipart/form-data

и далее, в первой части

    -----------------
    Content-Type: application/json; charset=UTF-8
    Content-Disposition: form-data; name="data"

после чего для каждого файла

    -----------------
    Content-Type: image/jpeg
    Content-Disposition: form-data; name="avatar"; filename="user.jpg"

Если вы используете защиту от CSRF (а лучше бы вам её использовать), то удобнее передавать CSRF-токен в отдельном заголовке (типа X-CSRF-Token) для всех запросов, а не внедрять вручную в каждый запрос. Хранить CSRF токен в куках плохо по той причине, что куки можно украсть, в чём собственно и состоит суть CSRF атаки.

## Структура URI

Нагородить можно всякое, но лучшая практика — чтобы все URI имели вид

/_:entity_[/_:id_][/?_:params_]

ну, или если у вас api лежит в какой-то папке,

/api/_:entity_[/_:id_][/?_:params_]

Здесь:

*   **entity** — название сущности, например, класса или таблицы/представления в БД. Примеры: `users`, `dictionary`
*   **id** _opt._ — первичный ключ объекта. Если первичный ключ составной, то части указываются через слэш. Примеры: `/users/10`, `/dictionary/ru/apptitle`
*   **params** _opt._ — дополнительные параметры выборки для списочных запросов (фильтрация, сортировка, паджинация и пр.). Форматируются по правилам HTTP GET параметров (функции encodeURIComponent и пр.)

Для разбора части URI до знака вопроса можно использовать регулярку

    #^/(<entity>([a-z]\-_)+)/?(<id>([a-z][A-Z][0-9]\-_/)*)?$#

Ведущий слэш обязателен, т.к. неизвестно, с какого URL будет осуществлён запрос.

## Методы HTTP

### `GET /:entity/:id` — **getById**

В случае успеха сервер возвращает `200 OK` с полями объекта в формате JSON в теле ответа (без дополнительного оборачивания в какой-либо объект)

В случае, если объект с такими id не существует, сервер возвращает `404 Not Found`

В ответе обязательно должны быть заголовки, касающиеся политики кэширования, т.к. браузеры активно кешируют GET и HEAD запросы. При остутствии какой-либо политики управления кэшем должно быть:

    Cache-Control: no-store, no-cache, must-revalidate
    Pragma: no-cache

### `GET /:entity[?param1=...&param2=...]` — списочный get

Простой случай: в случае успеха сервер возвращает `200 OK` с массивом объектов в формате JSON в теле ответа (т.е. ответ начинается с `[` и заканчивается `]`).

Если массив получился пустой, всё равно вовзращается `200 OK` с пустым масивом `[]` в теле ответа.

Более сложный вариант: возвращается объект, в одном из полей которого — искомый массив. В остальных полях — данные о пагинации, фильтры, счётчики и пр. Только держите это консистентным по всем api.

### `HEAD /:entity[/:id]` — запрос заголовков

Полный аналог GET с таким же URI, но не возвращает тело ответа, а только HTTP-заголовки.

Реализация поддержки HEAD запросов веб-сервером **обязательна**.

Активно используется браузерами в качестве автоматических pre-flight запросов перед выполнением потенциально опасных, по их мнению, операций. Например, браузер Chrome активно кидается head-запросами для получения политик CORS при кросс-доменных операциях (виджеты и пр). При этом ошибка обработки такого head-запроса приведёт к тому, что основной запрос вообще не будет выполнен браузером.

Может использоваться для проверки существования объекта без его передачи (например, для больших объектов типа мультимедиа-файлов).

### `POST /:entity` — создаёт новый объект типа :entity

В теле запроса должны быть перечислены поля объекта в формате JSON без дополнительного заворачивания, т.е. `{"field1":"value","field2":10}`

В случае успеха сервер должен возвращать `201 Created` с пустым телом, но с дополнительным заголовком

`Location: /:entity/:new_id`

указывающим на месторасположение созданного объекта.

Возвращать тело ответа чаще всего не требуется, так как у клиента есть все необходимые данные, а id созданного объекта он может получить из Location.

Также метод POST используется для удалённого вызова процедур (RPC), в этом случае ответ будет иметь статус `200 OK` и результаты в теле. Вообще смешивать REST и RPC в одном api — идея сомнительная, но всякое бывает.

Единственный неидемпотентный некешируемый метод, т.е. повтор двух одинаковых POST запросов создаст два одинаковых объекта.

### `PUT /:entity/:id` — изменяет объект целиком

В запросе должны содержаться **все** поля изменяемого объекта в формате JSON.

В случае успеха должен возвращать `204 No Data` с пустым телом, т.к. у клиента есть все необходимые данные.

Идемпотентный запрос, т.е. повторный PUT с таким же телом не приводит к каким-либо изменениям в БД.

### `PATCH /:entity/:id` — изменяет отдельные поля объекта

В запросе должны быть перечислены только поля, подлежащие изменению.

В случае успеха возвращает `200 OK` с телом, аналогичным запросу getById, со всеми полями изменённого объекта.

Используется с осторожностью, т.к. два параллельных PATCH от двух разных клиентов могут привести объект в невалидное состояние.

Идемпотентный запрос.

### `DELETE /:entity/:id` — удаляет объект, если он существует.

В случае успеха возвращает `204 No Data` с пустым телом, т.к. возвращать уже нечего.

Идемпотентный запрос, т.е. повторный DELETE с таким же адресом не приводит к ошибке 404.

### `OPTIONS /:entity[/:id]`

Получает список методов, доступных по данному URI.

Сервер должен ответить `200 OK` с дополнительным заголовком

    Allow: GET, POST, ...

Некешиуремый необязательный метод.

## Обработка ошибок

Возвращаемые ошибки передаются с сервера на клиент как ответы со статусами 4хх (ошибка клиента) или 5хх (ошибка сервера). При этом описание ошибки, если оно есть, приводится в теле ответа в формате text/plain (без всякого JSON). Соответственно, передаётся заголовок ответа

    Content-Type: text/plain; charset=UTF-8

Использовать html для оформления сообщений об ошибках в api — так себе идея, будут проблемы журналированием и т.д. Предполагается, что клиент способен сам красиво оформить сообщение об ошибке для пользователя.

При выборе конкретных кодов ошибок не следует слишком увлекаться и пытаться применить существующие коды только потому, что название кажется подходящим. У многих кодов есть дополнительные требования к наличию определённых заголовков и специальная обработка браузерами. Например, код 401 запускает HTTP-аутентификацию, которая будет странно смотреться в каком-нибудь приложении на react или electron.

**UPD** по мотивам комментариев. Клиенты у вас будут разные: не только веб и мобильные приложения, но и такие штуки, как запускалка интеграционных тестов (CI), балансировщик нагрузки или система мониторинга у админов. Использование или неиспользование того или иного статуса ошибки определяется тем, будет ли он полезен хоть какому-то клиенту (т.е. этот клиент сможет предпринять какие-то действия конкретно по этому коду) и, наоборот, не будет ли проблем у какого-то из клиентов из-за неиспользования вами этого кода. Придумать реальный use-case, когда реакция клиента будет различаться в зависимости от 404 или 410, довольно сложно. При этом отличий 404 от 200 или 500 — вагон и телега.

### `400 Bad Request`

Универсальный код ошибки, если серверу непонятен запрос от клиента.

### `403 Forbidden`

Возвращается, если операция запрещена для текущего пользователя. Если у оператора есть учётка с более высокими правами, он должен перелогиниться самостоятельно. См. также 419

### `404 Not Found`

Возвращается, если в запросе был указан неизвестный entity или id несуществующего объекта.

Списочные методы get не должны возвращать этот код при верном entity (см. выше).

Если запрос вообще не удалось разобрать, следует возвращать 418.

### `415 Unsupported Media Type`

Возвращается при загрузке файлов на сервер, если фактический формат переданного файла не поддерживается. Также может возвращаться, если не удалось распарсить JSON запроса, или сам запрос пришёл не в формате JSON.

### `418 I'm a Teapot`

Возвращается для неизвестных серверу запросов, которые не удалось даже разобрать. Обычно это указывает на ошибку в клиенте, типа ошибки при формировании URI, либо что версии протокола клиента и сервера не совпадают.

Этот ответ удобно использовать, чтобы отличать запросы на неизвестные URI (т.е. явные баги клиента) от ответов 404, у которых просто нет данных (элемент не найден). В отличие от 404, код 418 не бросается никаким промежуточным софтом. Альтернатива — использовать для обозначения ситуаций "элемент не найден" `410 Gone`, но это не совсем корректно, т.к. предполагает, что ресурс когда-то существовал. Да и выделить баги клиента из потока 404 будет сложнее.

### `419 Authentication Timeout`

Отправляется, если клиенту нужно пройти повторную авторизацию (например, протухли куки или CSRF токены). При этом на клиенте могут быть несохранённые данные, которые будут потеряны, если просто выкинуть клиента на страницу авторизации.

### `422 Unprocessable Entity`

Запрос корректно разобран, но содержание запроса не прошло серверную валидацию.

Например, в теле запроса были указаны неизвестные серверу поля, или не были указаны обязательные, или с содержимым полей что-то не так.

Обычно это означает ошибку в введённых пользователем данных, но может также быть вызвано ошибкой на клиенте или несовпадением версий.

### `500 Internal Server Error`

Возвращается, если на сервере вылетело необработанное исключение или произошла другая необработанная ошибка времени исполнения.

Всё, что может сделать клиент в этом случае — это уведомить пользователя и сделать `console.error(err)` для более продвинутых товарищей (админов, разработчиков и тестировщиков).

### `501 Not Implemented`

Возвращается, если текущий метод неприменим (не реализован) к объекту запроса.

* * *

Ну вот, в общем-то, и всё. Спасибо за внимание!
